import React from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, useGLTF, Center, PerspectiveCamera, Float } from '@react-three/drei';
import * as THREE from 'three';

function Model({ 
  url, 
  scale=1, 
  rotation=0, 
  animName,
  onAnimationsLoaded
}: { 
  url: string; 
  scale?: number; 
  rotation?: number; 
  animName?: string;
  onAnimationsLoaded?: (animations: THREE.AnimationClip[]) => void;
}) {
  const { scene, animations } = useGLTF(url);
  const mixer = React.useRef<THREE.AnimationMixer>();
  const activeAction = React.useRef<THREE.AnimationAction>();
  
  // Initialize mixer and load animations
  React.useEffect(() => {
    if (animations?.length && !mixer.current) {
      mixer.current = new THREE.AnimationMixer(scene);
      onAnimationsLoaded?.(animations);
    }
    
    // Set initial scale
    scene.scale.setScalar(scale);
    
    // Set initial rotation
    scene.rotation.y = rotation * Math.PI / 180;
    
  }, [scene, animations, scale, rotation, onAnimationsLoaded]);

  // Handle animation changes
  React.useEffect(() => {
    if (!mixer.current || !animations?.length || !animName) return;

    if (activeAction.current) {
      activeAction.current.fadeOut(0.5);
    }

    const clip = animations.find(a => a.name === animName);
    if (clip) {
      const nextAction = mixer.current.clipAction(clip);
      nextAction.reset().fadeIn(0.5).play();
      activeAction.current = nextAction;
    }

    return () => {
      if (activeAction.current) {
        activeAction.current.fadeOut(0.5);
      }
    };
  }, [animations, animName]);
  
  useFrame((_, delta) => mixer.current?.update(delta));

  return (
    <Center>
      <Float
        speed={1.5}
        rotationIntensity={0.5}
        floatIntensity={0.2}
      >
        <primitive object={scene} />
      </Float>
    </Center>
  );
}

export default function AnimalModelPreview({ modelUrl, scale=1, rotation=0, animName, onAnimationSelect }: { 
  modelUrl?: string; 
  scale?: number; 
  rotation?: number; 
  animName?: string;
  onAnimationSelect?: (name: string, animations: THREE.AnimationClip[]) => void;
}) {
  const handleAnimationsLoaded = React.useCallback((animations: THREE.AnimationClip[]) => {
    if (onAnimationSelect && animations.length > 0) {
      onAnimationSelect(
        animName || animations[0].name,
        animations
      );
    }
  }, [onAnimationSelect, animName]);

  if (!modelUrl) return (
    <div className="h-[600px] flex items-center justify-center text-sm opacity-70 bg-gray-900 rounded-lg">
      No model uploaded
    </div>
  );
  
  return (
    <div className="h-[600px] relative bg-gray-900 rounded-lg overflow-hidden">
      <Canvas shadows>
        <PerspectiveCamera 
          makeDefault 
          position={[2.5, 2, 2.5]} 
          fov={45}
          near={0.1}
          far={100}
        />
        <ambientLight intensity={0.7} />
        <spotLight 
          position={[5, 5, 5]} 
          angle={0.4} 
          penumbra={1} 
          intensity={0.5} 
          castShadow 
        />
        <spotLight 
          position={[-5, 5, -5]} 
          angle={0.4} 
          penumbra={1} 
          intensity={0.5} 
          castShadow 
        />
        <Model 
          url={modelUrl} 
          scale={scale} 
          rotation={rotation} 
          animName={animName} 
          onAnimationsLoaded={handleAnimationsLoaded}
        />
        <mesh 
          rotation={[-Math.PI / 2, 0, 0]} 
          position={[0, -1, 0]} 
          receiveShadow
        >
          <planeGeometry args={[100, 100]} />
          <shadowMaterial opacity={0.2} />
        </mesh>
        <OrbitControls 
          enablePan={false}
          minDistance={2}
          maxDistance={10}
          minPolarAngle={0}
          maxPolarAngle={Math.PI * 0.85}
          target={[0, 0, 0]}
          enableDamping
          dampingFactor={0.05}
        />
      </Canvas>
    </div>
  );
}
